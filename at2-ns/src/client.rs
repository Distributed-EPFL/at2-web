//! Client to connect to the name service

use std::collections::HashSet;

use http::Uri;
use snafu::{ResultExt, Snafu};

use crate::{
    proto::{name_service_client::NameServiceClient, *},
    FullUser, ThinUser,
};

/// Errors generated by the [`Client`]
#[derive(Debug, Snafu)]
pub enum Error {
    /// Deserializing the server's reply
    Deserialize {
        /// Source of the error
        source: bincode::Error,
    },
    /// Serializing the server's query
    Serialize {
        /// Source of the error
        source: bincode::Error,
    },
    /// Signing the request
    Signature {
        /// Source of the error
        source: drop::crypto::sign::SignError,
    },
    /// Communicating with the server
    #[snafu(display("server answered: {}", source.message()))]
    Rpc {
        /// Source of the error
        source: tonic::Status,
    },
}

type Result<T> = std::result::Result<T, Error>;

/// wasm only gRPC web client
#[derive(Clone)]
pub struct Client(NameServiceClient<grpc_web_client::Client>);

impl Client {
    /// Create a new Client connecting to the given [`Uri`]
    pub fn new(uri: &Uri) -> Self {
        let mut url_string = uri.to_string();
        if uri.path() == "/" {
            // TODO fix upstream handling
            url_string.pop();
        }

        Self(NameServiceClient::new(grpc_web_client::Client::new(
            url_string,
        )))
    }

    /// Put a new user, updating its name if already existing
    pub async fn put(&mut self, user: FullUser) -> Result<()> {
        self.0
            .put(PutRequest {
                account: Some(Account {
                    public_key: bincode::serialize(&user.public_key()).context(Serialize)?,
                    name: user.name.to_owned(),
                }),
                signature: bincode::serialize(&user.keypair().sign(&user.name).context(Signature)?)
                    .context(Serialize)?,
            })
            .await
            .context(Rpc)
            .map(|_| {})
    }

    /// Get all the registered users
    pub async fn get_all(&mut self) -> Result<HashSet<ThinUser>> {
        let reply = self.0.get_all(GetAllRequest {}).await.context(Rpc)?;

        reply
            .into_inner()
            .accounts
            .iter()
            .map(|account| {
                Ok(ThinUser::new(
                    account.name.clone(),
                    bincode::deserialize(&account.public_key).context(Deserialize)?,
                ))
            })
            .collect::<Result<HashSet<_>>>()
    }
}
